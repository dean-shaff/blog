---
layout: post
title: Multithreading in PyQt
date: '2016-07-26T14:31:00.002-07:00'
author: dshaff001
tags: 
modified_time: '2016-07-28T07:30:01.329-07:00'
blogger_id: tag:blogger.com,1999:blog-8551793629529973046.post-4111596191357942960
blogger_orig_url: http://deanshaff.blogspot.com/2016/07/multithreading-in-pyqt.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><script type="text/x-markdown">For my job, I use a GUI framework called Qt. Qt has been implemented in a number of languages (including Python, Ruby, C++ and even Lua), but I use the Python version. The piece of code I'm working on is pretty intricate, in that it has many processes that need to be happening at the same time. At any given time, there can be 5 or more threads running. These threads monitor various pieces of hardware (that need to share information) or update elements in the user interface. Qt has its own threading interface. It behaves similarly to Python's built in threading module. The thing to note about Qt's QThread is that it isn't thread safe. Practically what this means is that we can't modify UI elements from outside the main thread of the program. I'm working on a piece of code that was created by someone who was not aware of this limitation. As a result, we get the occasional segmentation fault. What I'm going to show is how I've implemented some of the threading in the application I'm working on. From what I can tell, this is not the preferred method. However, the preferred method didn't work for me.   Say we have a hardware controller that has a few channels. From each channel we get different text information. If we want to display the text information from the hardware controller without hanging up the UI, we'll have to start a Thread that continually grabs information from the hardware controller.  </script> <script src="https://gist.github.com/dean-shaff/218372f2a7ca83dc77743e82b4731d3c.js"></script> <script type="text/x-markdown">Here's how this works. In the first thread, I subclass PyQt's `QThread`. The only method that should be overridden is the "run" method. This is exactly the same as subclassing Pythons threading.Thread class. One never calls the start method directly. I create a class property, a pyqt signal, before even hitting __init__. If we try to define the signal elsewhere, PyQt will get lost. For some reason I'm not a huge fan of this syntax, but that's just me. Now I also define another method, in addition to the run method -- 'change_controller_num.' In reality, this method might help us use the UI to change some internal state of the hardware controller. Notice the `@QtCore.pyqtSlot(str)` decorator. Decorators are one of those features of the Python language that I don't interact with much. Here, it just indicates that this method is to be used to receive information from the UI. The use of `str` as the argument is indicating that we're using the type string. If you pass something that's not a Python type (or custom object -- I'm not sure, haven't tried) it'll throw an error.   In the second class, I define the basic UI. Now, I have deliberately not been explicit with the definition of the UI components. If you're reading through this and get confused because you can't see any the explicit creation of any Qt widgets, know that I define them in another file, built in Qt Designer. An aside: Qt Designer is great if you have Qt Designer, but it spits out auto-generated code that is largely unreadable. The Python code that Qt Designer generates for my project is ~5000 lines long! Assume that I have defined two components, a textBox and a spinbox, a QLabel and a QSpinBox respectively. Here's where the real magic happens that allows us to communicate asynchronously across two threads. I create an instance of the worker class. Then, I connect the worker's signal ('change_controller_num') to a method call in the main UI! So, when the worker thread is running, this signal will emit every time it runs through its internal while loop. Just to hammer this point in -- we have to do this because we cannot explicitly change UI elements from any thread expect the main thread. What about the other way around -- sending a signal to the worker thread, to tell it to modify it's state? This is why we have the `QtCore.pyqtSlot` decorator in the Worker thread. We send the signal using the following line      QtCore.QObject.connect(self.ui.spinbox, QtCore.SIGNAL('valueChanged(int)'), self.worker.change_controller_num)  What about safely exiting the threads? Using the machinery that Qt provides, we should have a `finished` signal that would connect to the QThreads built in `quit` method. I couldn't get this to work. Maybe this is me being an idiot, or it has to do with the specific version of Python and Qt I'm using. The `closeEvent` method takes care of closing the thread. First, it sets the worker's `running`  flag to `False`, then calls `quit`, and finally `wait`. Without the `wait` call, the application will exit without waiting for the thread to actually shut down. This will result in an error like "QThread destroyed while still running." This takes a hot second. Maybe this is why it always takes so damn long for devices to shut down -- they have to safely exit out of the hundreds of threads going on in the background.  </script></div>