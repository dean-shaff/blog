---
layout: post
title: Solving differential equations in Theano
date: '2016-09-03T13:30:00.000-07:00'
author: dshaff001
tags: 
modified_time: '2016-09-03T13:54:07.251-07:00'
blogger_id: tag:blogger.com,1999:blog-8551793629529973046.post-6882743485436094013
blogger_orig_url: http://deanshaff.blogspot.com/2016/09/solving-differential-equations-in-theano.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">I've spent some time messing around with Theano, building and training neural nets. For my senior thesis, I used my own implementation of a Theano neural net to classify waveforms in the XENON100 dark matter detector. I've even spent some time working on LSTMs for text generation (The latter project is essentially my attempt to implement Karpathy's char-rnn in Theano). My understanding is that Theano was built with training neural networks in mind, hence all the emphasis on automatic differentiation and GPU support. In reality, Theano is a general purpose symbolic math library with lots of convenient neural net functionality, like built in squashing functions, downsampling functions, and even 2D convolution functions. Theano is fast because it compiles code into C code on the fly. We make Theano functions by creating computational graphs using symbolic variables. This means that there is some overhead when running Theano code -- my LSTM might take as much as a minute to compile before it starts actually training.<br /><a name='more'></a><br />As Theano promises to be so fast, I've been wondering for a while if I could use it to solve differential equations. Moreover, I've been interested to know if it would be faster than equivalent Numpy code. For the purpose of this post, I chose to solve the Lorentz attractor equations using the 4th order Runge-Kutta method. These equations look as follows (from Wikipedia):<br />$$<br />\frac{dx}{dt} = \sigma(y - x) \\<br />\frac{dy}{dt} = x(\rho - z) - y \\<br />\frac{dz}{dt} = xy - \beta z \\<br />$$<br />Here $\sigma$, $\beta$ and $\rho$ are system parameters. This is a pretty cool looking set of equations when you visualize each of the variables $x$,$y$, and $z$ in three dimensions. Check it out <a href="http://dean-shaff.github.io/LorentzAttractor/LorentzAttractor.html">here</a>. I'm not interested in visualizing the results this time around. I simply want to do a speed comparison between two different implementations of the solution to this problem, while ensuring that I get the same result for both implementations.<br /><br /><script type="text/x-markdown">In the end, the Theano implementation outperformed the Numpy implementation, but only when we used Theano's `scan` function. If we make a Theano function that corresponds to a single Runge-Kutta step, we actually get *worse* performance than the Numpy version. When we use `scan`, the Theano version performs better, but only by a factor of two. I'd be interested to see how it does for a more complicated set of equations, like the Nbody equations. Check out the results:      $> python runge_kutta.py      Compilation time: 0.72444 seconds     Time in calculation (numpy): 0.02142     Time in calculation (theano): 0.01395     Same array? True  </script>  Note that I didn't run these in separate scripts, so we're running the Numpy and Theano implementations in the same program. Switching the order of which one went first didn't change the results. I made a github gist with all the code, and you can find it <a href="https://gist.github.com/dean-shaff/d1d0cdabf79e225ab96918b73916289f">here</a> (or just check it out below). Theano scan is a confusing beast that still doesn't make a whole hell of a lot of sense to me. Another thing to note is that the program spends the vast majority of its time compiling the Theano function that does the calculation. Unless you're doing something that is incredibly computationally expensive, it seems like it would be smart to just stick with good ole' Numpy.<br /><script src="https://gist.github.com/dean-shaff/d1d0cdabf79e225ab96918b73916289f.js"></script> </div> 